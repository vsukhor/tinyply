// This software is in the public domain. Where that dedication is not
// recognized, you are granted a perpetual, irrevocable license to copy,
// distribute, and modify this file as you see fit.
// https://github.com/ddiakopoulos/tinyply
// Version 2.3

// The purpose of this file is to demonstrate the tinyply API and provide
// several almost-complete functions that can be copied and pasted into your
// own application or library.
// Because tinyply treats the file format as structured data, it's up to you to
// copy or move the parsed data into your application-specific data structures
// (e.g. float3, vec3, etc).

#include "reader.h"
#include "writer.h"
#include "utils.h"

#include <filesystem>

namespace tinyply::examples {

template<typename T>
void write(const T& src,
           const std::filesystem::path& filename,
           const bool asBinary)
{
    namespace ply = tinyply;
    using Type = ply::Type;

    ply::FileOut file;

    file.add_properties_to_element("vertex",
                                        {"x", "y", "z"},
                                        Type::FLOAT32,
                                        src.vertices.size(),
                                        reinterpret_cast<uint8_t const*>(src.vertices.data()),
                                        Type::INVALID,
                                        0);

    file.add_properties_to_element("vertex",
                                        {"nx", "ny", "nz"},
                                        Type::FLOAT32,
                                        src.normals.size(),
                                        reinterpret_cast<uint8_t const*>(src.normals.data()),
                                        Type::INVALID,
                                        0);

    file.add_properties_to_element("vertex",
                                        {"u", "v"},
                                        Type::FLOAT32,
                                        src.texcoords.size() ,
                                        reinterpret_cast<uint8_t const*>(src.texcoords.data()),
                                        Type::INVALID,
                                        0);

    file.add_properties_to_element("face",
                                        {"vertex_indices"},
                                        Type::UINT32,
                                        src.triangles.size(),
                                        reinterpret_cast<uint8_t const*>(src.triangles.data()),
                                        Type::UINT8,
                                        3);

    file.add_comment("generated by tinyply 2.3");

    file.write(filename, asBinary);
}

template<typename T>
std::optional<T> read(const std::filesystem::path& file,
                      const bool preload_into_memory = true)
{
    std::cout << "..........................................................\n";
    std::cout << "Now Reading: " << file << std::endl;

    std::unique_ptr<std::istream> file_stream;
    std::vector<uint8_t> byte_buffer;

    try {
        // For most files < 1Gb, pre-loading the entire file upfront and
        // wrapping it into a stream is a net win for parsing speed,
        // about 40% faster.
        if (preload_into_memory) {

            byte_buffer = read_file_binary(file);
            file_stream.reset(new memory_stream((char*)byte_buffer.data(),
                                                byte_buffer.size()));
        }
        else
            file_stream.reset(new std::ifstream(file, std::ios::binary));

        if (!file_stream || file_stream->fail())
            throw std::runtime_error("file_stream failed to open " + file.string());

        file_stream->seekg(0, std::ios::end);
        const float size_mb = file_stream->tellg() * float(1e-6);
        file_stream->seekg(0, std::ios::beg);

        namespace ply = tinyply;
        ply::FileIn file;

        file.parse_header(*file_stream);

        file.report_structure();

        // Because most people have their own mesh types,
        // tinyply treats parsed data as structured/typed byte buffers.
        // See examples below on how to marry your own application-specific
        // data structures with this one.
        std::shared_ptr<FileIn::Data> vertices;
        std::shared_ptr<FileIn::Data> normals;
        std::shared_ptr<FileIn::Data> colors;
        std::shared_ptr<FileIn::Data> texcoords;
        std::shared_ptr<FileIn::Data> faces;
        std::shared_ptr<FileIn::Data> tripstrip;

        // The header information can be used to programmatically extract
        // properties on elements known to exist in the header prior to reading
        // the data. For brevity of this sample, properties
        // like vertex position are hard-coded:
        try {
            vertices = file.request_properties_from_element("vertex",
                                                            { "x", "y", "z" });
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }
        try {
            normals = file.request_properties_from_element("vertex",
                                                           {"nx", "ny", "nz"});
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        try {
            colors = file.request_properties_from_element("vertex",
                                                          {"red", "green", "blue", "alpha"});
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        try {
            colors = file.request_properties_from_element("vertex",
                                                          { "r", "g", "b", "a" });
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        try {
            texcoords = file.request_properties_from_element("vertex",
                                                             { "u", "v" });
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        // Providing a list size hint (the last argument) is a 2x performance
        // improvement. If you have arbitrary ply files, it is best to leave this 0.
        try {
            faces = file.request_properties_from_element("face",
                                                         {"vertex_indices"},
                                                         3);
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        // Tristrips must always be read with a 0 list size hint (unless you
        // know exactly how many elements are specifically in the file, which
        // is unlikely);
        try {
            tripstrip = file.request_properties_from_element("tristrips",
                                                             {"vertex_indices"},
                                                             0);
        }
        catch (const std::exception& e) {
            std::cerr << "tinyply exception: " << e.what() << std::endl;
        }

        manual_timer read_timer;

        read_timer.start();
        file.read(*file_stream);
        read_timer.stop();

        const float parsing_time = static_cast<float>(read_timer.get()) / 1000.f;
        std::cout << "\tparsing " << size_mb << "mb in "
                  << parsing_time << " seconds ["
                  << (size_mb / parsing_time) << " MBps]" << std::endl;

        if (vertices)   std::cout << "\tRead " << vertices->count  << " total vertices "<< std::endl;
        if (normals)    std::cout << "\tRead " << normals->count   << " total vertex normals " << std::endl;
        if (colors)     std::cout << "\tRead " << colors->count    << " total vertex colors " << std::endl;
        if (texcoords)  std::cout << "\tRead " << texcoords->count << " total vertex texcoords " << std::endl;
        if (faces)      std::cout << "\tRead " << faces->count     << " total faces (triangles) " << std::endl;
        if (tripstrip)  std::cout << "\tRead " << tripstrip->num_items() << " total indices (tristrip) " << std::endl;

        // Example One: converting to your own application types
        T body;

        const size_t sizeVertices = vertices->buffer.size_bytes();
        body.vertices.resize(vertices->count);
        std::memcpy(body.vertices.data(), vertices->buffer.get(), sizeVertices);

        const size_t sizeNormals = normals->buffer.size_bytes();
        body.normals.resize(normals->count);
        std::memcpy(body.normals.data(), normals->buffer.get(), sizeNormals);

        const size_t sizeTexCs = texcoords->buffer.size_bytes();
        body.texcoords.resize(texcoords->count);
        std::memcpy(body.texcoords.data(), texcoords->buffer.get(), sizeTexCs);

        body.set_triangles(Cube::quads);

        // Example Two: converting to your own application type
        {
            std::vector<float3> verts_floats;
            std::vector<double3> verts_doubles;

            if (vertices->t == ply::Type::FLOAT32) { /* as floats ... */ }
            if (vertices->t == ply::Type::FLOAT64) { /* as doubles ... */ }
        }

        return body;
    }
    catch (const std::exception& e) {
        std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
    }

    return {};
}

}  // namespace tinyply::examples

//  ////////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{
    namespace ply = tinyply;

    const std::string astr {std::filesystem::current_path()/"example_cube"};
    auto bstr = [](const bool b) { return b ? "binary" : "ascii"; };

    using Body = Cube;

    // Circular write-read:
    // object -> write ascii ->
    //           read ascii ->
    //           write binary ->
    //           read

    const auto cb0 = Body::default_configuration();
    // cb0.print("init");

    bool asBinary {};

    auto fname = astr + "0-" + bstr(asBinary) + ".ply";

    ply::examples::write<Body>(cb0, fname, asBinary);
    const auto cb1 = ply::examples::read<Body>(fname, asBinary);
    // cb1.value().print("after");

    fname = astr + "1-" + bstr(asBinary) + ".ply";

    ply::examples::write<Body>(cb1.value(), fname, asBinary);

    asBinary = true;

    fname = astr + "2-" + bstr(asBinary) + ".ply";

    ply::examples::write<Body>(cb1.value(), fname, asBinary);
    const auto cb2 = ply::examples::read<Body>(fname, asBinary);
    // cb2.value().print("after");

    asBinary = false;

    fname = astr + "3-" + bstr(asBinary) + ".ply";

    ply::examples::write<Body>(cb2.value(), fname, asBinary);

    return EXIT_SUCCESS;
}
